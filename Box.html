<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pudełko 3D – obrót myszką</title>
  <style>
    html,body{height:100%;margin:0}
    body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:#0f1217;color:#e6edf3}
    #app{display:grid;grid-template-rows:auto 1fr auto;min-height:100%}
    header,footer{padding:10px 14px;background:#0b0f14;border-bottom:1px solid #1f2430}
    footer{border-top:1px solid #1f2430;border-bottom:none;font-size:12px;color:#9fb0c0}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .viewer{position:relative}
    canvas{display:block;width:100%;height:calc(100vh - 120px)}
    .hint{position:absolute;left:10px;bottom:10px;background:#0b0f14aa;border:1px solid #1f2430;border-radius:8px;padding:6px 8px;font-size:12px;color:#9fb0c0}
    label,input,button{font-size:14px}
    input[type="file"],button{background:#0f141c;color:#e6edf3;border:1px solid #243244;border-radius:8px;padding:6px 10px}
    input[type="range"]{accent-color:#8ab4f8}
  </style>
</head>
<body>
<div id="app">
  <header>
    <div class="row">
      <strong>Pudełko 3D</strong>
      <span style="color:#9fb0c0">• Obracaj: lewy klawisz myszy • Zoom: kółko • Przesuwaj: prawy</span>
    </div>
  </header>

  <div class="viewer">
    <canvas id="three"></canvas>
    <div class="hint">Autoobrót: <input id="autorotate" type="checkbox"> &nbsp;Prędkość <input id="speed" type="range" min="0" max="5" step="0.1" value="1"></div>
  </div>

  <footer>
    Minimalny przykład: Three.js + OrbitControls z CDN. Brak zewnętrznych plików – wszystko generowane w przeglądarce.
  </footer>
</div>

<!-- Three.js -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
<script>
  const canvas = document.getElementById('three');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  const scene = new THREE.Scene(); scene.background = new THREE.Color(0x0f1217);
  const camera = new THREE.PerspectiveCamera(50, 1, 0.01, 100);
  camera.position.set(1.8,1.3,1.8);
  const controls = new THREE.OrbitControls(camera, canvas); controls.enableDamping = true;

  // Światła + podłoga
  scene.add(new THREE.HemisphereLight(0xffffff, 0x2a3340, 0.8));
  const sun = new THREE.DirectionalLight(0xffffff, 0.9); sun.position.set(2,2,1); scene.add(sun);
  const floor = new THREE.Mesh(new THREE.PlaneGeometry(10,10), new THREE.MeshStandardMaterial({color:0x0b0f14, roughness:1}));
  floor.rotation.x = -Math.PI/2; floor.position.y = -0.01; scene.add(floor);

  // Pudełko 3D (prostokątny karton) – wymiary przykładowe
  const L=0.22, H=0.12, W=0.16; // metry; nie ma to znaczenia, chodzi o proporcje

  // Proste "kartonowe" materiały na każdą ścianę (CanvasTexture)
  function cardCanvas(){
    const c=document.createElement('canvas'); c.width=c.height=512; const ctx=c.getContext('2d');
    const g=ctx.createLinearGradient(0,0,0,512); g.addColorStop(0,'#b88b55'); g.addColorStop(1,'#a7773f');
    ctx.fillStyle=g; ctx.fillRect(0,0,512,512); ctx.strokeStyle='rgba(0,0,0,.15)'; ctx.lineWidth=2; ctx.strokeRect(4,4,504,504); return new THREE.CanvasTexture(c);
  }
  const mats = Array.from({length:6}, ()=> new THREE.MeshStandardMaterial({map:cardCanvas(), roughness:.95}));
  const box = new THREE.Mesh(new THREE.BoxGeometry(L,H,W), mats); box.castShadow=true; scene.add(box);

  function resize(){
    const r = canvas.getBoundingClientRect();
    renderer.setSize(r.width || window.innerWidth, r.height || (window.innerHeight-120), false);
    camera.aspect = (r.width || window.innerWidth) / (r.height || (window.innerHeight-120));
    camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', resize, {passive:true}); resize();

  const auto = document.getElementById('autorotate');
  const speed = document.getElementById('speed');

  function loop(){
    controls.autoRotate = auto.checked;
    controls.autoRotateSpeed = +speed.value; // domyślnie 2.0
    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(loop);
  }
  loop();
</script>
</body>
</html>
